# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Merge multiple 10x mtx file sets into one set
#'
#' @param r_headers file set headers
#' @param r_batches unique batch names for each header
#' @param r_mtx_files A list of mtx files
#' @param r_row_files A list of row files
#' @param r_col_files A list of col files
#' @param r_fixed_rows A list of rows/features
#' @param output output file header
#' @param nnz_cutoff number of non-zero cutoff for columns
#' @param delim delimiter in the column name
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(10, 1, 1) # ten cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' t1 <- mmutil_simulate_poisson(mm, rr, "test1")
#' t2 <- mmutil_simulate_poisson(mm, rr, "test2")
#' bats <- hdrs <- c("test1","test2")
#' t3 <- mmutil_merge_file_sets(
#'                       hdrs, bats, "test3", 0)
#' A1 <- Matrix::readMM(t1$mtx);
#' rownames(A1) <- unlist(read.table(gzfile(t1$row)))
#' A2 <- Matrix::readMM(t2$mtx)
#' rownames(A2) <- unlist(read.table(gzfile(t2$row)))
#' A3 <- Matrix::readMM(t3$mtx)
#' rownames(A3) <- unlist(read.table(gzfile(t3$row)))
#' print(cbind(A1, A2))
#' print(A3)
#' unlink(list.files(pattern = "test1"))
#' unlink(list.files(pattern = "test2"))
#' unlink(list.files(pattern = "test3"))
#'
mmutil_merge_file_sets <- function(r_headers = NULL, r_batches = NULL, r_mtx_files = NULL, r_row_files = NULL, r_col_files = NULL, r_fixed_rows = NULL, output = "output", nnz_cutoff = 1, delim = "_") {
    .Call('_CHANGEME_mmutil_merge_file_sets', PACKAGE = 'CHANGEME', r_headers, r_batches, r_mtx_files, r_row_files, r_col_files, r_fixed_rows, output, nnz_cutoff, delim)
}

#' Take a subset of rows and create a new MTX file-set
#'
#' @description For the new mtx file, empty columns with only zero
#'   elements will be removed.
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param selected selected row names
#' @param output output
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' src.hdr <- "test_org"
#' src.files <- mmutil_simulate_poisson(mm, rr, src.hdr)
#' Y <- Matrix::readMM(src.files$mtx)
#' rownames(Y) <- read.table(src.files$row)$V1
#' print(Y)
#' sub.rows <- sort(read.table(src.files$row)$V1[sample(10,3)])
#' print(sub.rows)
#' tgt.hdr <- "test_sub"
#' tgt.files <- mmutil_copy_selected_rows(
#'                src.files$mtx,
#'                src.files$row,
#'                src.files$col,
#'                sub.rows,
#'                tgt.hdr)
#' Y <- Matrix::readMM(tgt.files$mtx)
#' colnames(Y) <- read.table(tgt.files$col)$V1
#' rownames(Y) <- read.table(tgt.files$row)$V1
#' print(Y)
#' unlink(list.files(pattern = src.hdr))
#' unlink(list.files(pattern = tgt.hdr))
#'
mmutil_copy_selected_rows <- function(mtx_file, row_file, col_file, r_selected, output) {
    .Call('_CHANGEME_mmutil_copy_selected_rows', PACKAGE = 'CHANGEME', mtx_file, row_file, col_file, r_selected, output)
}

#' Take a subset of columns and create a new MTX file-set
#'
#' @param mtx_file data file
#' @param row_file row file
#' @param col_file column file
#' @param selected selected column names
#'
#' @examples
#'
#' options(stringsAsFactors=FALSE)
#' rr <- rgamma(20, 1, 1)
#' mm <- matrix(rgamma(10 * 2, 1, 1), 10, 2)
#' src.hdr <- "test_org"
#' src.files <- mmutil_simulate_poisson(mm, rr, src.hdr)
#' Y <- Matrix::readMM(src.files$mtx)
#' colnames(Y) <- read.table(src.files$col)$V1
#' print(Y)
#' sub.cols <- sort(read.table(src.files$col)$V1[sample(20,3)])
#' print(sub.cols)
#' tgt.hdr <- "test_sub"
#' tgt.files <- mmutil_copy_selected_columns(
#'                          src.files$mtx,
#'                          src.files$row,
#'                          src.files$col,
#'                          sub.cols, tgt.hdr)
#' Y <- Matrix::readMM(tgt.files$mtx)
#' colnames(Y) <- read.table(tgt.files$col)$V1
#' print(Y)
#' unlink(list.files(pattern = src.hdr))
#' unlink(list.files(pattern = tgt.hdr))
#'
mmutil_copy_selected_columns <- function(mtx_file, row_file, col_file, r_selected, output) {
    .Call('_CHANGEME_mmutil_copy_selected_columns', PACKAGE = 'CHANGEME', mtx_file, row_file, col_file, r_selected, output)
}

#' Create an index file for a given MTX
#'
#' @param mtx_file data file
#' @param index_file index file
#'
#' @usage mmutil_build_index(mtx_file, index_file)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
mmutil_build_index <- function(mtx_file, index_file = "") {
    .Call('_CHANGEME_mmutil_build_index', PACKAGE = 'CHANGEME', mtx_file, index_file)
}

#' Read an index file to R
#'
#' @param index_file index file
#'
#' @return a vector column index (a vector of memory locations)
#'
mmutil_read_index <- function(index_file) {
    .Call('_CHANGEME_mmutil_read_index', PACKAGE = 'CHANGEME', index_file)
}

#' Check if the index tab is valid
#'
#' @param mtx_file data file
#' @param index_tab index tab (a vector of memory locations)
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
#'
mmutil_check_index <- function(mtx_file, index_tab) {
    .Call('_CHANGEME_mmutil_check_index', PACKAGE = 'CHANGEME', mtx_file, index_tab)
}

#' Just read the header information
#'
#' @param mtx_file data file
#'
#' @return info
#'
mmutil_info <- function(mtx_file) {
    .Call('_CHANGEME_mmutil_info', PACKAGE = 'CHANGEME', mtx_file)
}

#' Write down sparse matrix to the disk
#' @param X sparse matrix
#' @param mtx_file file name
#'
#' @return EXIT_SUCCESS or EXIT_FAILURE
mmutil_write_mtx <- function(X, mtx_file) {
    .Call('_CHANGEME_mmutil_write_mtx', PACKAGE = 'CHANGEME', X, mtx_file)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return lists of rows, columns, values
#'
mmutil_read_columns_sparse <- function(mtx_file, memory_location, r_column_index, verbose = FALSE, NUM_THREADS = 1L, MIN_SIZE = 10L) {
    .Call('_CHANGEME_mmutil_read_columns_sparse', PACKAGE = 'CHANGEME', mtx_file, memory_location, r_column_index, verbose, NUM_THREADS, MIN_SIZE)
}

#' Read a subset of columns from the data matrix
#' @param mtx_file data file
#' @param memory_location column -> memory location
#' @param r_column_index column indexes to retrieve (1-based)
#'
#' @return a dense sub-matrix
#'
#' @examples
#'
#' rr <- rgamma(100, 1, 1) # one hundred cells
#' mm <- matrix(rgamma(10 * 3, 1, 1), 10, 3)
#' data.hdr <- "test_sim"
#' .files <- mmutilR::mmutil_simulate_poisson(mm, rr, data.hdr)
#' data.file <- .files$mtx
#' idx.file <- .files$idx
#' mtx.idx <- mmutilR::mmutil_read_index(idx.file)
#' Y <- as.matrix(Matrix::readMM(data.file))
#' col.pos <- c(1,13,77) # 1-based
#' yy <- mmutilR::mmutil_read_columns(
#'                  data.file, mtx.idx, col.pos)
#' all(Y[, col.pos, drop = FALSE] == yy)
#' print(head(Y[, col.pos, drop = FALSE]))
#' print(head(yy))
#' unlink(list.files(pattern = data.hdr))
#'
mmutil_read_columns <- function(mtx_file, memory_location, r_column_index, verbose = FALSE, NUM_THREADS = 1L, MIN_SIZE = 10L) {
    .Call('_CHANGEME_mmutil_read_columns', PACKAGE = 'CHANGEME', mtx_file, memory_location, r_column_index, verbose, NUM_THREADS, MIN_SIZE)
}

#' Simulate sparse counting data with a mixture of Poisson parameters
#'
#'
#' @param r_mu_list a list of gene x individual matrices
#' @param Ncell the total number of cells (may not make it if too sparse)
#' @param output a file header string for output files
#' @param dir_alpha a parameter for Dirichlet(alpha * [1, ..., 1])
#' @param gam_alpha a parameter for Gamma(alpha, beta)
#' @param gam_beta a parameter for Gamma(alpha, beta)
#' @param rseed random seed
#'
mmutil_simulate_poisson_mixture <- function(r_mu_list, Ncell, output, dir_alpha = 1.0, gam_alpha = 2.0, gam_beta = 2.0, rseed = 42L) {
    .Call('_CHANGEME_mmutil_simulate_poisson_mixture', PACKAGE = 'CHANGEME', r_mu_list, Ncell, output, dir_alpha, gam_alpha, gam_beta, rseed)
}

#' Simulation Poisson data based on Mu
#'
#' M= num. of features and n= num. of indv
#'
#' @param mu depth-adjusted mean matrix (M x n)
#' @param rho column depth vector (N x 1), N= num. of cells
#' @param output header for ${output}.{mtx.gz,cols.gz,indv.gz}
#' @param r_indv N x 1 individual membership (1-based, [1 .. n])
#' @param rseed random seed
#'
#' @return a list of file names: {output}.{mtx,rows,cols}.gz
#'
mmutil_simulate_poisson <- function(mu, rho, output, r_indv = NULL, rseed = 42L) {
    .Call('_CHANGEME_mmutil_simulate_poisson', PACKAGE = 'CHANGEME', mu, rho, output, r_indv, rseed)
}

